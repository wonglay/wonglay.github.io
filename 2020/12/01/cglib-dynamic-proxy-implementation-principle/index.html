<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="CGLIB动态代理实现原理分析"><meta name="keywords" content="CGLIB,动态代理,Java"><meta name="author" content="wonglay"><meta name="copyright" content="wonglay"><title>CGLIB动态代理实现原理分析 | WongLay's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-9645725473564504',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?05bbd66f90cb23aab0181d6dd8d10cc6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta name="google-site-verification" content="tK1Wy_UJrHP7qLjl7yECyz1cxhxrqOdZ-pFuz50j26Y"><meta name="msvalidate.01" content="3B9B16E44464B03A91C86799BD912328"><meta name="baidu-site-verification" content="code-9fvN1xvFho"><meta name="360-site-verification" content="06d52fd6e1c1ef85085fa9c9619c5b31"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7UFHVLIKJE","apiKey":"48020e4765303361fb0e85518c15e27a","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="WongLay's Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#CGLIB%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">CGLIB介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGLIB-API"><span class="toc-number">2.</span> <span class="toc-text">CGLIB API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8CGLIB-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">用CGLIB 创建代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">创建一个简单的代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E7%9A%84%E4%BB%A3%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">创建一个复杂的代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8MethodInterceptor"><span class="toc-number">3.2.1.</span> <span class="toc-text">使用MethodInterceptor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8CallbackFilter"><span class="toc-number">3.2.2.</span> <span class="toc-text">使用CallbackFilter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6"><span class="toc-number">4.</span> <span class="toc-text">底层实现原理探究</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/avatar.jpg"></div><div class="author-info__name text-center">wonglay</div><div class="author-info__description text-center">Java developer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://blog-wonglay.oss-cn-beijing.aliyuncs.com/cb8bbc9581b2450624ae81adf5f4a814.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">WongLay's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">CGLIB动态代理实现原理分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.2k</span><span class="post-meta__separator">|</span><span>Reading time: 17 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="CGLIB介绍"><a href="#CGLIB介绍" class="headerlink" title="CGLIB介绍"></a>CGLIB介绍</h3><p>​        CGLIB是一个功能强大的高性能代码生成库。它被广泛应用于基于代理的AOP框架（如springaop和dynaop）中，以提供方法拦截。Hibernate作为最流行的ORM工具，也使用CGLIB库代理单端关联（除了collection lazy loading，它使用另一种机制）。EasyMock和jMock是流行的Java测试库。它们提供模拟对象来支持测试。两者都使用CGLIB代理没有接口的类。<br>​        CGLIB库使用ASM（一种轻量级但高性能的字节码操作框架）来转换字节码并生成新的类(如图1.1)。</p>
<p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20201218173519.jpg" alt="图1.1"></p>
<p>除了CGLIB之外，Groovy和Bean Shell等脚本语言也使用ASM来生成Java字节码。ASM使用类似于SAX analyzer的机制来实现高性能。但是，并不推荐直接使用ASM，因为这需要对JVM有很深的了解，包括类文件格式和指令集。<br>        另外，像Spring AOP和Hibernate这样的框架经常使用CGLIB和JDK动态代理来满足各自的需求。Hibernate使用JDK动态代理为webshere应用服务实现事务管理适配器；Spring AOP默认情况下使用JDK动态代理来代理接口，除非强制使用CGLIB，或者代理没有实现接口的类。</p>
<h3 id="CGLIB-API"><a href="#CGLIB-API" class="headerlink" title="CGLIB API"></a>CGLIB API</h3><p>​        CGLIB库虽然只有少量代码，但是由于缺乏文档，学习难度较大。CGLIB库的包结构如图2.1(本文采用Cglib 3.1)：</p>
<p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20201218143134.jpg" alt="图2.1"></p>
<ul>
<li>net.sf.cglib.beans：Java bean 相关的工具类</li>
<li>net.sf.cglib.core：底层字节码操作相关的类；大多数与ASP相关</li>
<li>net.sf.cglib.proxy：代理创建和方法拦截相关的类</li>
<li>net.sf.cglib.reflect：反射相关的类</li>
<li>net.sf.cglib.transform：编译和运行时类文件转换相关的类</li>
<li>net.sf.cglib.util：集合排序工具相关类</li>
</ul>
<p>对于创建动态代理，在大多数情况下，只需要使用代理包的部分API。<br>如上所述，CGLIB库基于ASM的上层应用程序。CGLIB对于代理不实现接口的类非常有用。本质上，对于需要代理的类，它只是动态地生成一个子类来覆盖非final方法，同时绑定钩子函数来回调自定义拦截器，这样就可以对目标类进行增强。值得一提的是，它比JDK动态代理更快。</p>
<p>net.sf.cglib.proxy.MethodInterceptor是最常用的回调类型，通常用于在基于代理的AOP实现中拦截方法回调。此接口只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * General-purpose &#123;<span class="doctag">@link</span> Enhancer&#125; callback which provides for &quot;around advice&quot;.//提供环绕通知的能力</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juozas Baliuka &lt;a href=&quot;mailto:baliuka@mwm.lt&quot;&gt;baliuka@mwm.lt&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> $Id: MethodInterceptor.java,v 1.8 2004/06/24 21:15:20 herbyderby Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * All generated proxied methods call this method instead of the original method.</span></span><br><span class="line"><span class="comment">     * The original method may either be invoked by normal reflection using the Method object,</span></span><br><span class="line"><span class="comment">     * or by using the MethodProxy (faster).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj &quot;this&quot;, the enhanced object // 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method intercepted Method // 目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args argument array; primitive types are wrapped // 目标方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy used to invoke super (non-intercepted method); may be called</span></span><br><span class="line"><span class="comment">     * as many times as needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable any exception may be thrown; if so, super method will not be invoked</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> any value compatible with the signature of the proxied method. Method returning void will ignore this value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> MethodProxy</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果net.sf.cglib.proxy.MethodInterceptor被设置为方法回调，当调用代理方法时，它调会用MethodInterceptor.intercept方法，然后再调用代理对象的方法,也就是目标方法。MethodInterceptor的intercept方法的第一个参数是代理对象，第二个参数和第三个参数分别是被拦截的方法和方法的参数，最后一个参数是代理方法。如果要调用代理对象的原始方法，可以使用java.lang.reflect方法对象来反射调用，或net.sf.cglib.proxy.MethodProxy对象。我们通常用net.sf.cglib.proxy.MethodProxy.MethodProxy，因为它更快。在intercept方法中，可以在目标方法调用之前或之后注入自定义代码(环绕通知)。</p>
<p>net.sf.cglib.proxy.MethodInterceptor满足大部分场景代理要求，但对于某些特定场景可能不太方便。为了易于使用和高性能，CGLIB提供了其他特殊的回调类型。例如，</p>
<ul>
<li>net.sf.cglib.proxy.FixedValue：在特定情况下，强制特定方法返回固定值，是非常有用和高性能的。</li>
</ul>
<ul>
<li>net.sf.cglib.proxy.NoOp：它直接传递父类的方法实现。</li>
</ul>
<ul>
<li>net.sf.cglib.proxy.LazyLoader：这在需要延迟加载代理对象的情况下非常有用。如果加载了代理对象，它将在以后的代理调用中重用。</li>
</ul>
<ul>
<li>net.sf.cglib.Dispatcher：类似于net.sf.cglib.proxy.LazyLoader，但每次调用代理方法时，都会调用loadObject方法来加载代理对象。</li>
</ul>
<ul>
<li>net.sf.cglib.proxy.ProxyRefDispatcher：与Dispatcher相同，但其loadObject方法支持传入的代理对象。</li>
</ul>
<p>我们通常对代理类的所有方法使用相同的回调，但是我们也可以使用net.sf.cglib.proxy.callsFilter对不同的方法使用不同的回调。然而JDK动态代理并没有提供这样的细粒度的控制。也就是说JDK中， java.lang.reflect.InvocationHandler的invoke方法不能对不同方法使用不同回调，只能使用相同的回调。</p>
<p>现在让我们看看如何使用CGLIB创建代理。</p>
<h3 id="用CGLIB-创建代理"><a href="#用CGLIB-创建代理" class="headerlink" title="用CGLIB 创建代理"></a>用CGLIB 创建代理</h3><p>​        使用Cglib可以很方便的创建代理。</p>
<h4 id="创建一个简单的代理"><a href="#创建一个简单的代理" class="headerlink" title="创建一个简单的代理"></a>创建一个简单的代理</h4><p>​        只需要传入一个目标类即可，Cglib就可以为该类创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetClass 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">     Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">     enhancer.setSuperclass(targetClass);</span><br><span class="line">     enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line">     <span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法的返回值是目标类对象的代理。在上面的例子中，net.sf.cglib.proxy.Enhancer 配置了一个net.sf.cglib.proxy.Callback。如你所见，使用CGLIB创建一个简单的代理很容易。除了new一个net.sf.cglib.proxy.Enhancer对象，也可以net.sf.cglib.proxy.Enhancer中的静态辅助方法直接创建。但是建议使用示例中的方法，因为可以配net.sf.cglib.proxy.Enhancer对象来更精确地控制生成的代理。</p>
<p>值得注意的是，我们将目标类作为代理的父类传入。与JDK动态代理不同，我们不能使用目标对象来创建代理。目标对象只能由CGLIB创建。在本例中，默认的参数化构造函数用于创建目标对象。如果希望CGLIB用参数创建一个实例，那么应该使用net.sf.cglib.proxy.Enhancer.create(Class[]，Object[]）。方法的第一个参数指定参数类型，第二个参数指定参数值。参数中的基本类型需要包装类型。</p>
<h4 id="创建一个复杂的代理"><a href="#创建一个复杂的代理" class="headerlink" title="创建一个复杂的代理"></a>创建一个复杂的代理</h4><p>​        说复杂其实也不复杂，只是相对与上面简单类型而言，多了一些回调接口来实现不同类型的通知对目标类增强，例如前置通知等。</p>
<h5 id="使用MethodInterceptor"><a href="#使用MethodInterceptor" class="headerlink" title="使用MethodInterceptor"></a>使用MethodInterceptor</h5><p>​        我们可以替换net.sf.cglib.proxy.NoOp，实现net.sf.cglib.proxy.MethodInterceptor接口以获得更强的代理。代理对象的所有方法调用都分配给的intercept方法net.sf.cglib.proxy.MethodInterceptor. intercept方法然后调用底层对象。</p>
<p>​        假设您要检查是否有权限调用目标对象的某个方法，如果授权失败，可以抛出一个运行时异常AuthorizationException(本例中只是简单打印信息)。接口授权.java具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 简单的授权服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthorizationService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">authorize</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> net.sf.cglib.proxy.MethodInterceptor接口的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 一个简单的MethodInterceptor实现，应用AuthorizationService授权服务</span></span><br><span class="line"><span class="comment"> * 在调用代理方法前检查权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthorizationService authorizationService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizationInterceptor</span><span class="params">(AuthorizationService authorizationService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorizationService = authorizationService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (authorizationService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果授权失败，可以抛出AuthorizationException</span></span><br><span class="line">            authorizationService.authorize(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在intercept方法中，首先检查授权，如果授权通过，intercept方法调用目标对象的方法。出于性能原因，我们使用CGLIB net.sf.cglib.proxy.MethodProxy对象而不是常规java.lang.reflect方法反射对象来调用原始方法。</p>
<h5 id="使用CallbackFilter"><a href="#使用CallbackFilter" class="headerlink" title="使用CallbackFilter"></a>使用CallbackFilter</h5><p>​        net.sf.cglib.proxy.callsFilter允许在方法级别设置回调。假设有一个PersistenceServiceImpl类，它有两个方法：save和load。save方法需要授权检查，而load方法不需要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> PersistenceService接口简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersistenceService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Long id, String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(data + <span class="string">&quot; has been saved successfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;wonglay.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PersistenceService接口的net.sf.cglib.proxy.CallbackFilter实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceCallbackFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save方法在callback数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SAVE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save方法在callback数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOAD = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定哪个callback被调用当这个方法被调用的时候，callback</span></span><br><span class="line"><span class="comment">     * 就是一个MethodInterceptor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 正在被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 这个方法在callback数组中的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;save&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SAVE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LOAD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>accept方法将代理方法映射到MethodInterceptor，也即callback。这个方法返回callback对象数组的下标。下面是为PersistenceServiceImpl类创建代理对象的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.NoOp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置需要代理的类</span></span><br><span class="line">        enhancer.setSuperclass(PersistenceServiceImpl.class);</span><br><span class="line">		<span class="comment">// 设置PersistenceServiceImpl需要增强(检查权限)的方法过滤器</span></span><br><span class="line">        CallbackFilter callbackFilter = <span class="keyword">new</span> PersistenceServiceCallbackFilter();</span><br><span class="line">        enhancer.setCallbackFilter(callbackFilter);</span><br><span class="line">		<span class="comment">// AuthorizationService 的简单实现</span></span><br><span class="line">        AuthorizationService authorizationService = (method) -&gt; &#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + methodName + <span class="string">&quot;] method authenticating...&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">       </span><br><span class="line">        Callback saveCallback = <span class="keyword">new</span> AuthorizationInterceptor(authorizationService);</span><br><span class="line">        Callback loadCallback = NoOp.INSTANCE;</span><br><span class="line">	    <span class="comment">// 设置Callback</span></span><br><span class="line">        Callback[] callbacks = <span class="keyword">new</span> Callback[]&#123;saveCallback, loadCallback&#125;;</span><br><span class="line">        enhancer.setCallbacks(callbacks);</span><br><span class="line">		<span class="comment">// 创建代理对象</span></span><br><span class="line">        PersistenceServiceImpl persistenceService = (PersistenceServiceImpl) enhancer.create();</span><br><span class="line">        System.out.println(persistenceService.load(<span class="number">1L</span>));</span><br><span class="line">        persistenceService.save(<span class="number">2L</span>, <span class="string">&quot;wonglay.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如图3.2.2，load方法调用没有打印权限检查信息，而save方法打印了权限检查信息，原因是load方法使用了NoOp.INSTANCE callback，它只是一个线程安全的空实现，而save方法使用了AuthorizationInterceptor callback对目标类进行增加，这里的通知(Advice)类型为前置通知。</p>
<p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20201218171429.jpg" alt="图3.2.2"></p>
<p>在本例中，授权拦截器应用于save方法，NoOp.INSTANCE 应用于load方法。你可以通net.sf.cglib.proxy.Enhancer.setInterfaces(Class [])指定代理需要实现的接口，但这不是必需的。<br>        对于net.sf.cglib.proxy.Enhancer，除了设置callback对象的数组外，还可以使用net.sf.cglib.proxy.Enhancer.setCallbackTypes(Class [])设置callback对象的数组。如果在代理创建期间没有实际的callback对象，则此方法非常有用。与callback对象一样，还需要使用net.sf.cglib.proxy.callsFilter为每个拦截方法指定callback对象数组的下标。</p>
<h3 id="底层实现原理探究"><a href="#底层实现原理探究" class="headerlink" title="底层实现原理探究"></a>底层实现原理探究</h3><p>​        当调用Enhancer的create方法创建代理对象时底层回调用下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       	Class gen = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">synchronized</span> (source) &#123;</span><br><span class="line">               ClassLoader loader = getClassLoader();</span><br><span class="line">               Map cache2 = <span class="keyword">null</span>;</span><br><span class="line">               cache2 = (Map)source.cache.get(loader);</span><br><span class="line">               <span class="keyword">if</span> (cache2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   cache2 = <span class="keyword">new</span> HashMap();</span><br><span class="line">                   cache2.put(NAME_KEY, <span class="keyword">new</span> HashSet());</span><br><span class="line">                   source.cache.put(loader, cache2);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (useCache) &#123;</span><br><span class="line">                   Reference ref = (Reference)cache2.get(key);</span><br><span class="line">                   gen = (Class) (( ref == <span class="keyword">null</span> ) ? <span class="keyword">null</span> : ref.get()); </span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (gen == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 先从当前线程获取</span></span><br><span class="line">                   Object save = CURRENT.get();</span><br><span class="line">                   CURRENT.set(<span class="keyword">this</span>);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">this</span>.key = key;</span><br><span class="line">                       <span class="keyword">if</span> (attemptLoad) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               gen = loader.loadClass(getClassName());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                               <span class="comment">// ignore</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (gen == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">byte</span>[] b = strategy.generate(<span class="keyword">this</span>);</span><br><span class="line">                           String className = ClassNameReader.getClassName(<span class="keyword">new</span> ClassReader(b));</span><br><span class="line">                           getClassNameCache(loader).add(className);</span><br><span class="line">                           <span class="comment">// 生成Class对象</span></span><br><span class="line">                           gen = ReflectUtils.defineClass(className, b, loader);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (useCache) &#123;</span><br><span class="line">                           cache2.put(key, <span class="keyword">new</span> WeakReference(gen));</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 利用反射创建对象</span></span><br><span class="line">                       <span class="keyword">return</span> firstInstance(gen);</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       CURRENT.set(save);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> firstInstance(gen);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过给JVM加一个Debug属性，使生成的代理对象输出到磁盘：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将CGLIB用字节码框架ASM生成的Class文件输出的到磁盘</span></span><br><span class="line">      System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;D:\\java&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">      enhancer.setSuperclass(PersistenceServiceImpl.class);</span><br><span class="line">    	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的Class文件用IDE反编译得到如下代理类，此对象继承了目标对象，并且实现了Factory接口，该接口可用于创建此代理类型相同的实例，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.Signature;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Factory;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.NoOp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceImpl</span>$$<span class="title">EnhancerByCGLIB</span>$$<span class="title">f5def17a</span> <span class="keyword">extends</span> <span class="title">PersistenceServiceImpl</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// callbacks函数是否要和当前线程绑定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="comment">// 用于存放需要和当前线程绑定的callbacks</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    <span class="comment">// 本例中对应AuthorizationInterceptor</span></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="comment">// 本例中对应NoOp.INSTANCE</span></span><br><span class="line">    <span class="keyword">private</span> NoOp CGLIB$CALLBACK_1;</span><br><span class="line">    <span class="comment">// save的Method对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$save$<span class="number">1</span>$Method;</span><br><span class="line">    <span class="comment">// 为save方法创建的代理对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$save$<span class="number">1</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] CGLIB$emptyArgs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  CGLIB$save$1$Method 和 CGLIB$save$1$Proxy 对象就是MethodInterceptor接口的入参</span></span><br><span class="line"><span class="comment">    *  用MethodProxy 比用 Method反射调用方法更快</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        Class var0 = Class.forName(<span class="string">&quot;com.wonglay.PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a&quot;</span>);</span><br><span class="line">        Class var1;</span><br><span class="line">        <span class="comment">// 通过方法名称和方法描述符获取到save的Method对象</span></span><br><span class="line">        CGLIB$save$<span class="number">1</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;save&quot;</span>, <span class="string">&quot;(Ljava/lang/Long;Ljava/lang/String;)V&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;com.wonglay.PersistenceServiceImpl&quot;</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 为方法创建一个代理方法</span></span><br><span class="line">        CGLIB$save$<span class="number">1</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/Long;Ljava/lang/String;)V&quot;</span>, <span class="string">&quot;save&quot;</span>, <span class="string">&quot;CGLIB$save$1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$save$<span class="number">1</span>(Long var1, String var2) &#123;</span><br><span class="line">        <span class="keyword">super</span>.save(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  此方法重载了PersistenceServiceImpl的save方法，由于load方法的callback函数为NoOp.INSTANCE</span></span><br><span class="line"><span class="comment">    *  ，是一个空实现，所以未重载load方法，所以会直接调用PersistenceServiceImpl的load方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Long var1, String var2)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时调用MethodInterceptor的interceptor方法，在此interceptor方法进行通知</span></span><br><span class="line">            <span class="comment">// CGLIB$save$1$Method，CGLIB$save$1$Proxy参数在静态块中已经初始化了</span></span><br><span class="line">            var10000.intercept(<span class="keyword">this</span>, CGLIB$save$<span class="number">1</span>$Method, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;, CGLIB$save$<span class="number">1</span>$Proxy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.save(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodProxy CGLIB$findMethodProxy(Signature var0) &#123;</span><br><span class="line">        String var10000 = var0.toString();</span><br><span class="line">        <span class="keyword">switch</span>(var10000.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">279689439</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;save(Ljava/lang/Long;Ljava/lang/String;)V&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$save$<span class="number">1</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = var0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将callbacks绑定到当前线下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a var1 = (PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a)var0;</span><br><span class="line">        <span class="keyword">if</span> (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = <span class="keyword">true</span>;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">                <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Callback[] var10001 = (Callback[])var10000;</span><br><span class="line">            var1.CGLIB$CALLBACK_1 = (NoOp)((Callback[])var10000)[<span class="number">1</span>];</span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)var10001[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 实现了Factory接口的方法，用于创建此类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var1);</span><br><span class="line">        PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a var10000 = <span class="keyword">new</span> PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;More than one callback object required&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 实现了Factory接口的方法，用于创建此类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Class[] var1, Object[] var2, Callback[] var3)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var3);</span><br><span class="line">        PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a var10000 = <span class="keyword">new</span> PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a;</span><br><span class="line">        <span class="keyword">switch</span>(var1.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000.&lt;init&gt;();</span><br><span class="line">            CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> var10000;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Constructor not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        Object var10000;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            var10000 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Callback)var10000;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">int</span> var1, Callback var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">this</span>.CGLIB$CALLBACK_1 = (NoOp)var2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="keyword">public</span> Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callback[]&#123;<span class="keyword">this</span>.CGLIB$CALLBACK_0, <span class="keyword">this</span>.CGLIB$CALLBACK_1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_1 = (NoOp)var1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// JVM加载这个类时会进行初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成的代理对象继承了目标对象，并重写了目标对象的方法以此来达到增强目标对象的目的。实现net.sf.cglib.proxy.Factory的目的是提供一些创建代理对象实例的工厂方法，这些方法会比反射创建对象快。另外，要拦截在对象构造期间调用的方法，必须使用这些方法而不是反射。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        CGLIB是一个功能强大的高性能代码生成库。作为对JDK动态代理的补充，它为不实现接口的类提供代理解决方案。在底部，它使用ASM字节码操作框架。实际上，CGLIB通过生成子类来重写非final方法来代理。它比使用Java反射的JDK动态代理方法更快。CGLIB不能代理final类或final方法。一般来说，可以使用JDK动态代理方法来创建代理。对于没有接口或性能因素的情况，CGLIB是一个很好的选择。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">wonglay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://wonglay.com/2020/12/01/cglib-dynamic-proxy-implementation-principle/">https://wonglay.com/2020/12/01/cglib-dynamic-proxy-implementation-principle/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CGLIB/">CGLIB</a><a class="post-meta__tags" href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">动态代理</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/01/jdk-dynamic-proxy-implementation-principle/"><i class="fa fa-chevron-left">  </i><span>JDK动态代理实现原理分析</span></a></div><div class="next-post pull-right"><a href="/2020/12/01/cccc/"><span>CGLIB动态代理实现原理分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'e80ac868ed08c584a590',
  clientSecret: '87199d807e0e0f3575f83a15132b0683eba25bc5',
  repo: 'blog-conversition',
  owner: 'wonglay',
  admin: 'wonglay',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://blog-wonglay.oss-cn-beijing.aliyuncs.com/cb8bbc9581b2450624ae81adf5f4a814.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2023 By wonglay</div><div class="framework-info"></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>