<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WongLay&#39;s Blog</title>
  
  
  <link href="https://wonglay.com/atom.xml" rel="self"/>
  
  <link href="https://wonglay.com/"/>
  <updated>2021-01-13T14:03:24.000Z</updated>
  <id>https://wonglay.com/</id>
  
  <author>
    <name>wonglay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK动态代理实现原理分析</title>
    <link href="https://wonglay.com/2021/01/01/jdk-dynamic-proxy-implementation-principle/"/>
    <id>https://wonglay.com/2021/01/01/jdk-dynamic-proxy-implementation-principle/</id>
    <published>2021-01-01T00:00:00.000Z</published>
    <updated>2021-01-13T14:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理允许在运行时通过反射创建Java接口的实现。代理可以被看作是一个将方法调用转发给目标实例并最终将目标实例产生的任何结果返回给调用方的主体。由于调用链将通过代理，代理本身也将能够在目标方法调用前后执行任意处理。非常流行的Spring框架使用JDK动态代理作为其代理创建策略之一。当我们在Spring服务中声明一个事务方法时，容器将创建一个代理，该代理将拦截对目标方法的调用，并用所需的事务管理指令来修饰它。</p><p>JDK动态代理是JDK附带的一个特性，由java.lang.reflect.* 包提供支持。它必须使用接口来提供代理对象。在JDK动态代理逻辑中，必须实现java.lang.reflect.InvocationHandler接口才能实现代理逻辑类。实现JDK动态代理需要几下几步：</p><ul><li>创建接口</li><li>创建一个接口实现类的实例对象，这个实例对象就是目标对象</li><li>创建一个代理类，这个类必须实现java.lang.reflect.InvocationHandler接口</li></ul><h3 id="JDK动态代理相关类介绍"><a href="#JDK动态代理相关类介绍" class="headerlink" title="JDK动态代理相关类介绍"></a>JDK动态代理相关类介绍</h3><p>在Java的动态代理机制中，有两个重要的类和接口，一个是InvocationHandler（Interface），另一个是proxy（Class），这个类和接口必须用来实现动态代理。</p><h4 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h4><p>每个动态代理类必须实现java.lang.reflect.InvocationHandler，每个代理类得是实例都与一个handler关联，当我们通过一个代理对象调用一个方法，对这个方法的调用被转发给InvocationHandler接口的invoke方法调用，然后在这个接口中通过反射调用这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口有三个参数：</p><ul><li>Proxy：指JDK动态生成的final修饰的代理对象</li><li>Method：指的是我们要调用目标对象的方法的方法对象</li><li>Args：指调用目标对象的方法的方法参数</li></ul><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>代理类的作用是动态创建代理对象类，最常用的方法是newProxyInstance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newProxyInstance方法的三个参数分别如下：</p><ul><li>Loader：一个类加载器对象，它定义了要为加载生成代理对象的类加载器。</li><li>Interfaces：一个接口对象数组，这意味着我们将为需要代理的对象提供一组接口，生成的代理对象实现这些接口。</li><li>InvocationHandler ：一个InvocationHandler对象，它表示在动态代理对象调用方法时与哪个InvocationHandler对象关联。可以把它理解为一个拦截器，拦截方法的调用，在目标方法调用前后进行通知。</li></ul><h3 id="用JDK代理创建代理"><a href="#用JDK代理创建代理" class="headerlink" title="用JDK代理创建代理"></a>用JDK代理创建代理</h3><p>动态代理类是一个类，它是在运行时生成的类。生成它时，必须向它提供一组接口。然后类公布这些接口的实现。你可以将类实例用作这些接口中的任何一个。当然，这个类是一个代理。它不会做实质性的工作。在生成他的实例时，必须提供一个handler来接管实际工作。</p><p> 假设你要检查是否有权限调用目标对象的某个方法，如果授权失败，可以抛出一个运行时异常AuthorizationException(本例中只是简单打印信息)。接口授权具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 简单的授权服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthorizationService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">authorize</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设有一个PersistenceServiceImpl类实现了PersistenceService接口，它有两个方法：save和load。现在需要检查是否有权限调用这两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> PersistenceService接口简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersistenceService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Long id, String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(data + <span class="string">&quot; has been saved successfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;wonglay.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在授权接口和需要授权的接口都有了，现在需要将这两个类关联起来，我们需要实现一个InvocationHandler接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于权限检查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthorizationService authorizationService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersistenceServiceInvocationHandler</span><span class="params">(AuthorizationService authorizationService, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorizationService = authorizationService;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// do前置通知</span></span><br><span class="line">        authorizationService.authorize(method);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// do其他后置通知。。。。</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的代理类会继承一个java.lang.reflect.Proxy类，java.lang.reflect.Proxy类声明了一个InvocationHandler变量，调用代理对象的方法时会委托给InvocationHandler(本例中就是PersistenceServiceInvocationHandler)的invoke，在invoke方法中通过反射调用目标方法，因此可以对方法进行增强。这几个类之间的关系如图3.1。</p><p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20210107165204.png" alt="图3.1"></p><p>面是为PersistenceServicel类创建代理对象的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        PersistenceService persistenceService = <span class="keyword">new</span> PersistenceServiceImpl();</span><br><span class="line">        <span class="comment">// 权限检查的简单实现</span></span><br><span class="line">        AuthorizationService authorizationService = (method) -&gt; &#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + methodName + <span class="string">&quot;] method authenticating...&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 设置权限检查服务和目标对象</span></span><br><span class="line">        PersistenceServiceInvocationHandler persistenceServiceInvocationHandler =</span><br><span class="line">                <span class="keyword">new</span> PersistenceServiceInvocationHandler(authorizationService, persistenceService);</span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">        PersistenceService proxy = (PersistenceService) persistenceServiceInvocationHandler.getProxy();</span><br><span class="line"></span><br><span class="line">        System.out.println(proxy.load(<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如图3.2</p><p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20210107170420.jpg" alt="图3.2"></p><h3 id="实现原理探究"><a href="#实现原理探究" class="headerlink" title="实现原理探究"></a>实现原理探究</h3><p>上面只是简单介绍了一下创建代理的过程，接下来将分析具体JDK是如何生成代理类，以及生成的代理类是什么样子，我们可以加上一个JVM参数，将生成的代理类写到磁盘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">           PersistenceService persistenceService = <span class="keyword">new</span> PersistenceServiceImpl();</span><br><span class="line">        <span class="comment">// 权限检查的简单实现</span></span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成的代理类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wonglay.PersistenceService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">PersistenceService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// equals方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="comment">// toString方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="comment">// save方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="comment">// load方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="comment">// hashCode方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数将为IocationHandler赋值</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用InvocationHandler(PersistenceServiceInvocationHandler)的invoke方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Long var1, String var2)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用InvocationHandler的invoke方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">load</span><span class="params">(Long var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM加载此类时会初始化这段代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            <span class="comment">// 得到PersistenceService的save方法对象</span></span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;com.wonglay.PersistenceService&quot;</span>).getMethod(<span class="string">&quot;save&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Long&quot;</span>), Class.forName(<span class="string">&quot;java.lang.String&quot;</span>));</span><br><span class="line">            <span class="comment">// 得到PersistenceService的load方法对象</span></span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.wonglay.PersistenceService&quot;</span>).getMethod(<span class="string">&quot;load&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Long&quot;</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy.newProxyInstance方法是怎么生成代理类的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        InvocationHandler h)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">      <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">      <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">          checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里生成代理类通过类加载器和接口生成代理类</span></span><br><span class="line">      Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">              checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">          <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">          <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">              AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                      cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 调用代理类的构造方法，构造方法的参数就是InvocationHandler对象</span></span><br><span class="line"><span class="comment">                * 对应代理对象的构造方法</span></span><br><span class="line"><span class="comment">                * public $Proxy0(InvocationHandler var1) throws  &#123;</span></span><br><span class="line"><span class="comment">                *      super(var1);</span></span><br><span class="line"><span class="comment">                * &#125;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">          <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">          Throwable t = e.getCause();</span><br><span class="line">          <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">              <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p> 继续看这一行代代码  Class&lt;?&gt; cl = getProxyClass0(loader, intfs)，点进去会看到如下方法，会先从一个叫WeakCache的缓存类获取代理类，如果获取不到在创建代理类,这个缓存对象是Proxy类的一个成员变量，在JVM加载Proxy类时就会执行赋值操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">       proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p>WeakCache类中获取代理对象的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">       Objects.requireNonNull(parameter);</span><br><span class="line">       expungeStaleEntries();</span><br><span class="line">       Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line">       <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">       ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">       <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">               = map.putIfAbsent(cacheKey,</span><br><span class="line">                                 valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">           <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">               valuesMap = oldValuesMap;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line">       <span class="comment">// subKey from valuesMap</span></span><br><span class="line">       Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">       Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">       Factory factory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 直到获取到代理对象才会返回</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">             <span class="comment">// 可能是存在的实例，也可能是Factory生成的实例</span></span><br><span class="line">               V value = supplier.get();</span><br><span class="line">               <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> value;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果创建代理类的工厂为null则创建</span></span><br><span class="line">           <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">               factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">           &#125;</span><br><span class="line">   <span class="comment">//如果代理工厂为null 赋值代理工厂</span></span><br><span class="line">           <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">               supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">               <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// successfully installed Factory</span></span><br><span class="line">                   supplier = factory;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// else retry with winning supplier</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                   <span class="comment">// successfully replaced</span></span><br><span class="line">                   <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                   <span class="comment">// with our Factory</span></span><br><span class="line">                   supplier = factory;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// retry with current supplier</span></span><br><span class="line">                   supplier = valuesMap.get(subKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接下来再看下代理工厂是怎么生成代理类的，如下是ProxyClassFactory的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">       implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 代理对象类名前缀</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line">       <span class="comment">// 代理对象类名后缀</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">           Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">              <span class="comment">// 验证类加载器是否将此接口的名称解析为相同的类对象，因为在JVM中一个类是由类本身和类加载器共同决定</span></span><br><span class="line">               Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                       intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">              <span class="comment">// 判断是否是接口，必须是接口才可以</span></span><br><span class="line">               <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                       interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 接口不能重复</span></span><br><span class="line">               <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                       <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">           <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">         <span class="comment">// 校验所有非public修饰的接口在同一包下，以便生成的代理类在同一包下</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">               <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                   accessFlags = Modifier.FINAL;</span><br><span class="line">                   String name = intf.getName();</span><br><span class="line">                   <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                   String pkg = ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                   <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       proxyPkg = pkg;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 如果都是public修饰的接口生成的代理类会在com.sun.proxy下，否则为接口所在的包下</span></span><br><span class="line">               proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 生成类全名</span></span><br><span class="line">           <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">           String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line">           <span class="comment">// 生成代理</span></span><br><span class="line">           <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">               proxyName, interfaces, accessFlags);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                   proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上就是整个对JDK动态代理实现原理的分析。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>诚然，Proxy 已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持 interface 代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫 Proxy。Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理，原因是多继承在 Java 中本质上就行不通。</p><p>有很多条理由，人们可以否定对 class 代理的必要性，但是同样有一些理由，相信支持 class 动态代理会更美好。接口和类的划分，本就不是很明显，只是到了 Java 中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是如果必须代理类，CGLIB是一个不错的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h3&gt;&lt;p&gt;JDK动态代理允许在运行时通过反射创建Java接口的实现。代理可以被看作是一个将方法调用转发给目标实</summary>
      
    
    
    
    <category term="随笔" scheme="https://wonglay.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="动态代理" scheme="https://wonglay.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="Java" scheme="https://wonglay.com/tags/Java/"/>
    
    <category term="JDK" scheme="https://wonglay.com/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>CGLIB动态代理实现原理分析</title>
    <link href="https://wonglay.com/2020/12/01/cglib-dynamic-proxy-implementation-principle/"/>
    <id>https://wonglay.com/2020/12/01/cglib-dynamic-proxy-implementation-principle/</id>
    <published>2020-12-01T00:00:00.000Z</published>
    <updated>2021-01-13T13:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CGLIB介绍"><a href="#CGLIB介绍" class="headerlink" title="CGLIB介绍"></a>CGLIB介绍</h3><p>​        CGLIB是一个功能强大的高性能代码生成库。它被广泛应用于基于代理的AOP框架（如springaop和dynaop）中，以提供方法拦截。Hibernate作为最流行的ORM工具，也使用CGLIB库代理单端关联（除了collection lazy loading，它使用另一种机制）。EasyMock和jMock是流行的Java测试库。它们提供模拟对象来支持测试。两者都使用CGLIB代理没有接口的类。<br>​        CGLIB库使用ASM（一种轻量级但高性能的字节码操作框架）来转换字节码并生成新的类(如图1.1)。</p><p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20201218173519.jpg" alt="图1.1"></p><p>除了CGLIB之外，Groovy和Bean Shell等脚本语言也使用ASM来生成Java字节码。ASM使用类似于SAX analyzer的机制来实现高性能。但是，并不推荐直接使用ASM，因为这需要对JVM有很深的了解，包括类文件格式和指令集。<br>        另外，像Spring AOP和Hibernate这样的框架经常使用CGLIB和JDK动态代理来满足各自的需求。Hibernate使用JDK动态代理为webshere应用服务实现事务管理适配器；Spring AOP默认情况下使用JDK动态代理来代理接口，除非强制使用CGLIB，或者代理没有实现接口的类。</p><h3 id="CGLIB-API"><a href="#CGLIB-API" class="headerlink" title="CGLIB API"></a>CGLIB API</h3><p>​        CGLIB库虽然只有少量代码，但是由于缺乏文档，学习难度较大。CGLIB库的包结构如图2.1(本文采用Cglib 3.1)：</p><p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20201218143134.jpg" alt="图2.1"></p><ul><li>net.sf.cglib.beans：Java bean 相关的工具类</li><li>net.sf.cglib.core：底层字节码操作相关的类；大多数与ASP相关</li><li>net.sf.cglib.proxy：代理创建和方法拦截相关的类</li><li>net.sf.cglib.reflect：反射相关的类</li><li>net.sf.cglib.transform：编译和运行时类文件转换相关的类</li><li>net.sf.cglib.util：集合排序工具相关类</li></ul><p>对于创建动态代理，在大多数情况下，只需要使用代理包的部分API。<br>如上所述，CGLIB库基于ASM的上层应用程序。CGLIB对于代理不实现接口的类非常有用。本质上，对于需要代理的类，它只是动态地生成一个子类来覆盖非final方法，同时绑定钩子函数来回调自定义拦截器，这样就可以对目标类进行增强。值得一提的是，它比JDK动态代理更快。</p><p>net.sf.cglib.proxy.MethodInterceptor是最常用的回调类型，通常用于在基于代理的AOP实现中拦截方法回调。此接口只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * General-purpose &#123;<span class="doctag">@link</span> Enhancer&#125; callback which provides for &quot;around advice&quot;.//提供环绕通知的能力</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juozas Baliuka &lt;a href=&quot;mailto:baliuka@mwm.lt&quot;&gt;baliuka@mwm.lt&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> $Id: MethodInterceptor.java,v 1.8 2004/06/24 21:15:20 herbyderby Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * All generated proxied methods call this method instead of the original method.</span></span><br><span class="line"><span class="comment">     * The original method may either be invoked by normal reflection using the Method object,</span></span><br><span class="line"><span class="comment">     * or by using the MethodProxy (faster).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj &quot;this&quot;, the enhanced object // 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method intercepted Method // 目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args argument array; primitive types are wrapped // 目标方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy used to invoke super (non-intercepted method); may be called</span></span><br><span class="line"><span class="comment">     * as many times as needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable any exception may be thrown; if so, super method will not be invoked</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> any value compatible with the signature of the proxied method. Method returning void will ignore this value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> MethodProxy</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果net.sf.cglib.proxy.MethodInterceptor被设置为方法回调，当调用代理方法时，它调会用MethodInterceptor.intercept方法，然后再调用代理对象的方法,也就是目标方法。MethodInterceptor的intercept方法的第一个参数是代理对象，第二个参数和第三个参数分别是被拦截的方法和方法的参数，最后一个参数是代理方法。如果要调用代理对象的原始方法，可以使用java.lang.reflect方法对象来反射调用，或net.sf.cglib.proxy.MethodProxy对象。我们通常用net.sf.cglib.proxy.MethodProxy.MethodProxy，因为它更快。在intercept方法中，可以在目标方法调用之前或之后注入自定义代码(环绕通知)。</p><p>net.sf.cglib.proxy.MethodInterceptor满足大部分场景代理要求，但对于某些特定场景可能不太方便。为了易于使用和高性能，CGLIB提供了其他特殊的回调类型。例如，</p><ul><li>net.sf.cglib.proxy.FixedValue：在特定情况下，强制特定方法返回固定值，是非常有用和高性能的。</li></ul><ul><li>net.sf.cglib.proxy.NoOp：它直接传递父类的方法实现。</li></ul><ul><li>net.sf.cglib.proxy.LazyLoader：这在需要延迟加载代理对象的情况下非常有用。如果加载了代理对象，它将在以后的代理调用中重用。</li></ul><ul><li>net.sf.cglib.Dispatcher：类似于net.sf.cglib.proxy.LazyLoader，但每次调用代理方法时，都会调用loadObject方法来加载代理对象。</li></ul><ul><li>net.sf.cglib.proxy.ProxyRefDispatcher：与Dispatcher相同，但其loadObject方法支持传入的代理对象。</li></ul><p>我们通常对代理类的所有方法使用相同的回调，但是我们也可以使用net.sf.cglib.proxy.callsFilter对不同的方法使用不同的回调。然而JDK动态代理并没有提供这样的细粒度的控制。也就是说JDK中， java.lang.reflect.InvocationHandler的invoke方法不能对不同方法使用不同回调，只能使用相同的回调。</p><p>现在让我们看看如何使用CGLIB创建代理。</p><h3 id="用CGLIB-创建代理"><a href="#用CGLIB-创建代理" class="headerlink" title="用CGLIB 创建代理"></a>用CGLIB 创建代理</h3><p>​        使用Cglib可以很方便的创建代理。</p><h4 id="创建一个简单的代理"><a href="#创建一个简单的代理" class="headerlink" title="创建一个简单的代理"></a>创建一个简单的代理</h4><p>​        只需要传入一个目标类即可，Cglib就可以为该类创建代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetClass 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">     Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">     enhancer.setSuperclass(targetClass);</span><br><span class="line">     enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line">     <span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的返回值是目标类对象的代理。在上面的例子中，net.sf.cglib.proxy.Enhancer 配置了一个net.sf.cglib.proxy.Callback。如你所见，使用CGLIB创建一个简单的代理很容易。除了new一个net.sf.cglib.proxy.Enhancer对象，也可以net.sf.cglib.proxy.Enhancer中的静态辅助方法直接创建。但是建议使用示例中的方法，因为可以配net.sf.cglib.proxy.Enhancer对象来更精确地控制生成的代理。</p><p>值得注意的是，我们将目标类作为代理的父类传入。与JDK动态代理不同，我们不能使用目标对象来创建代理。目标对象只能由CGLIB创建。在本例中，默认的参数化构造函数用于创建目标对象。如果希望CGLIB用参数创建一个实例，那么应该使用net.sf.cglib.proxy.Enhancer.create(Class[]，Object[]）。方法的第一个参数指定参数类型，第二个参数指定参数值。参数中的基本类型需要包装类型。</p><h4 id="创建一个复杂的代理"><a href="#创建一个复杂的代理" class="headerlink" title="创建一个复杂的代理"></a>创建一个复杂的代理</h4><p>​        说复杂其实也不复杂，只是相对与上面简单类型而言，多了一些回调接口来实现不同类型的通知对目标类增强，例如前置通知等。</p><h5 id="使用MethodInterceptor"><a href="#使用MethodInterceptor" class="headerlink" title="使用MethodInterceptor"></a>使用MethodInterceptor</h5><p>​        我们可以替换net.sf.cglib.proxy.NoOp，实现net.sf.cglib.proxy.MethodInterceptor接口以获得更强的代理。代理对象的所有方法调用都分配给的intercept方法net.sf.cglib.proxy.MethodInterceptor. intercept方法然后调用底层对象。</p><p>​        假设您要检查是否有权限调用目标对象的某个方法，如果授权失败，可以抛出一个运行时异常AuthorizationException(本例中只是简单打印信息)。接口授权.java具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 简单的授权服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthorizationService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">authorize</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> net.sf.cglib.proxy.MethodInterceptor接口的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 一个简单的MethodInterceptor实现，应用AuthorizationService授权服务</span></span><br><span class="line"><span class="comment"> * 在调用代理方法前检查权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthorizationService authorizationService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizationInterceptor</span><span class="params">(AuthorizationService authorizationService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorizationService = authorizationService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (authorizationService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果授权失败，可以抛出AuthorizationException</span></span><br><span class="line">            authorizationService.authorize(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在intercept方法中，首先检查授权，如果授权通过，intercept方法调用目标对象的方法。出于性能原因，我们使用CGLIB net.sf.cglib.proxy.MethodProxy对象而不是常规java.lang.reflect方法反射对象来调用原始方法。</p><h5 id="使用CallbackFilter"><a href="#使用CallbackFilter" class="headerlink" title="使用CallbackFilter"></a>使用CallbackFilter</h5><p>​        net.sf.cglib.proxy.callsFilter允许在方法级别设置回调。假设有一个PersistenceServiceImpl类，它有两个方法：save和load。save方法需要授权检查，而load方法不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> PersistenceService接口简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersistenceService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Long id, String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(data + <span class="string">&quot; has been saved successfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;wonglay.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PersistenceService接口的net.sf.cglib.proxy.CallbackFilter实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceCallbackFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save方法在callback数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SAVE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save方法在callback数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOAD = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定哪个callback被调用当这个方法被调用的时候，callback</span></span><br><span class="line"><span class="comment">     * 就是一个MethodInterceptor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 正在被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 这个方法在callback数组中的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;save&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SAVE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LOAD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>accept方法将代理方法映射到MethodInterceptor，也即callback。这个方法返回callback对象数组的下标。下面是为PersistenceServiceImpl类创建代理对象的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.NoOp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置需要代理的类</span></span><br><span class="line">        enhancer.setSuperclass(PersistenceServiceImpl.class);</span><br><span class="line"><span class="comment">// 设置PersistenceServiceImpl需要增强(检查权限)的方法过滤器</span></span><br><span class="line">        CallbackFilter callbackFilter = <span class="keyword">new</span> PersistenceServiceCallbackFilter();</span><br><span class="line">        enhancer.setCallbackFilter(callbackFilter);</span><br><span class="line"><span class="comment">// AuthorizationService 的简单实现</span></span><br><span class="line">        AuthorizationService authorizationService = (method) -&gt; &#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + methodName + <span class="string">&quot;] method authenticating...&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">       </span><br><span class="line">        Callback saveCallback = <span class="keyword">new</span> AuthorizationInterceptor(authorizationService);</span><br><span class="line">        Callback loadCallback = NoOp.INSTANCE;</span><br><span class="line">    <span class="comment">// 设置Callback</span></span><br><span class="line">        Callback[] callbacks = <span class="keyword">new</span> Callback[]&#123;saveCallback, loadCallback&#125;;</span><br><span class="line">        enhancer.setCallbacks(callbacks);</span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line">        PersistenceServiceImpl persistenceService = (PersistenceServiceImpl) enhancer.create();</span><br><span class="line">        System.out.println(persistenceService.load(<span class="number">1L</span>));</span><br><span class="line">        persistenceService.save(<span class="number">2L</span>, <span class="string">&quot;wonglay.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如图3.2.2，load方法调用没有打印权限检查信息，而save方法打印了权限检查信息，原因是load方法使用了NoOp.INSTANCE callback，它只是一个线程安全的空实现，而save方法使用了AuthorizationInterceptor callback对目标类进行增加，这里的通知(Advice)类型为前置通知。</p><p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20201218171429.jpg" alt="图3.2.2"></p><p>在本例中，授权拦截器应用于save方法，NoOp.INSTANCE 应用于load方法。你可以通net.sf.cglib.proxy.Enhancer.setInterfaces(Class [])指定代理需要实现的接口，但这不是必需的。<br>        对于net.sf.cglib.proxy.Enhancer，除了设置callback对象的数组外，还可以使用net.sf.cglib.proxy.Enhancer.setCallbackTypes(Class [])设置callback对象的数组。如果在代理创建期间没有实际的callback对象，则此方法非常有用。与callback对象一样，还需要使用net.sf.cglib.proxy.callsFilter为每个拦截方法指定callback对象数组的下标。</p><h3 id="底层实现原理探究"><a href="#底层实现原理探究" class="headerlink" title="底层实现原理探究"></a>底层实现原理探究</h3><p>​        当调用Enhancer的create方法创建代理对象时底层回调用下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Class gen = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">synchronized</span> (source) &#123;</span><br><span class="line">               ClassLoader loader = getClassLoader();</span><br><span class="line">               Map cache2 = <span class="keyword">null</span>;</span><br><span class="line">               cache2 = (Map)source.cache.get(loader);</span><br><span class="line">               <span class="keyword">if</span> (cache2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   cache2 = <span class="keyword">new</span> HashMap();</span><br><span class="line">                   cache2.put(NAME_KEY, <span class="keyword">new</span> HashSet());</span><br><span class="line">                   source.cache.put(loader, cache2);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (useCache) &#123;</span><br><span class="line">                   Reference ref = (Reference)cache2.get(key);</span><br><span class="line">                   gen = (Class) (( ref == <span class="keyword">null</span> ) ? <span class="keyword">null</span> : ref.get()); </span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (gen == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 先从当前线程获取</span></span><br><span class="line">                   Object save = CURRENT.get();</span><br><span class="line">                   CURRENT.set(<span class="keyword">this</span>);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">this</span>.key = key;</span><br><span class="line">                       <span class="keyword">if</span> (attemptLoad) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               gen = loader.loadClass(getClassName());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                               <span class="comment">// ignore</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (gen == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">byte</span>[] b = strategy.generate(<span class="keyword">this</span>);</span><br><span class="line">                           String className = ClassNameReader.getClassName(<span class="keyword">new</span> ClassReader(b));</span><br><span class="line">                           getClassNameCache(loader).add(className);</span><br><span class="line">                           <span class="comment">// 生成Class对象</span></span><br><span class="line">                           gen = ReflectUtils.defineClass(className, b, loader);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (useCache) &#123;</span><br><span class="line">                           cache2.put(key, <span class="keyword">new</span> WeakReference(gen));</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 利用反射创建对象</span></span><br><span class="line">                       <span class="keyword">return</span> firstInstance(gen);</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       CURRENT.set(save);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> firstInstance(gen);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们可以通过给JVM加一个Debug属性，使生成的代理对象输出到磁盘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将CGLIB用字节码框架ASM生成的Class文件输出的到磁盘</span></span><br><span class="line">      System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;D:\\java&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">      enhancer.setSuperclass(PersistenceServiceImpl.class);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的Class文件用IDE反编译得到如下代理类，此对象继承了目标对象，并且实现了Factory接口，该接口可用于创建此代理类型相同的实例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.Signature;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Factory;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.NoOp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceImpl</span>$$<span class="title">EnhancerByCGLIB</span>$$<span class="title">f5def17a</span> <span class="keyword">extends</span> <span class="title">PersistenceServiceImpl</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// callbacks函数是否要和当前线程绑定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="comment">// 用于存放需要和当前线程绑定的callbacks</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    <span class="comment">// 本例中对应AuthorizationInterceptor</span></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="comment">// 本例中对应NoOp.INSTANCE</span></span><br><span class="line">    <span class="keyword">private</span> NoOp CGLIB$CALLBACK_1;</span><br><span class="line">    <span class="comment">// save的Method对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$save$<span class="number">1</span>$Method;</span><br><span class="line">    <span class="comment">// 为save方法创建的代理对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$save$<span class="number">1</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] CGLIB$emptyArgs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  CGLIB$save$1$Method 和 CGLIB$save$1$Proxy 对象就是MethodInterceptor接口的入参</span></span><br><span class="line"><span class="comment">    *  用MethodProxy 比用 Method反射调用方法更快</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        Class var0 = Class.forName(<span class="string">&quot;com.wonglay.PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a&quot;</span>);</span><br><span class="line">        Class var1;</span><br><span class="line">        <span class="comment">// 通过方法名称和方法描述符获取到save的Method对象</span></span><br><span class="line">        CGLIB$save$<span class="number">1</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;save&quot;</span>, <span class="string">&quot;(Ljava/lang/Long;Ljava/lang/String;)V&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;com.wonglay.PersistenceServiceImpl&quot;</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 为方法创建一个代理方法</span></span><br><span class="line">        CGLIB$save$<span class="number">1</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/Long;Ljava/lang/String;)V&quot;</span>, <span class="string">&quot;save&quot;</span>, <span class="string">&quot;CGLIB$save$1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$save$<span class="number">1</span>(Long var1, String var2) &#123;</span><br><span class="line">        <span class="keyword">super</span>.save(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  此方法重载了PersistenceServiceImpl的save方法，由于load方法的callback函数为NoOp.INSTANCE</span></span><br><span class="line"><span class="comment">    *  ，是一个空实现，所以未重载load方法，所以会直接调用PersistenceServiceImpl的load方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Long var1, String var2)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时调用MethodInterceptor的interceptor方法，在此interceptor方法进行通知</span></span><br><span class="line">            <span class="comment">// CGLIB$save$1$Method，CGLIB$save$1$Proxy参数在静态块中已经初始化了</span></span><br><span class="line">            var10000.intercept(<span class="keyword">this</span>, CGLIB$save$<span class="number">1</span>$Method, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;, CGLIB$save$<span class="number">1</span>$Proxy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.save(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodProxy CGLIB$findMethodProxy(Signature var0) &#123;</span><br><span class="line">        String var10000 = var0.toString();</span><br><span class="line">        <span class="keyword">switch</span>(var10000.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">279689439</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;save(Ljava/lang/Long;Ljava/lang/String;)V&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$save$<span class="number">1</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = var0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将callbacks绑定到当前线下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a var1 = (PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a)var0;</span><br><span class="line">        <span class="keyword">if</span> (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = <span class="keyword">true</span>;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">                <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Callback[] var10001 = (Callback[])var10000;</span><br><span class="line">            var1.CGLIB$CALLBACK_1 = (NoOp)((Callback[])var10000)[<span class="number">1</span>];</span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)var10001[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法，用于创建此类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var1);</span><br><span class="line">        PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a var10000 = <span class="keyword">new</span> PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;More than one callback object required&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法，用于创建此类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Class[] var1, Object[] var2, Callback[] var3)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var3);</span><br><span class="line">        PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a var10000 = <span class="keyword">new</span> PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a;</span><br><span class="line">        <span class="keyword">switch</span>(var1.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000.&lt;init&gt;();</span><br><span class="line">            CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> var10000;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Constructor not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        Object var10000;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            var10000 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Callback)var10000;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">int</span> var1, Callback var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">this</span>.CGLIB$CALLBACK_1 = (NoOp)var2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="keyword">public</span> Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callback[]&#123;<span class="keyword">this</span>.CGLIB$CALLBACK_0, <span class="keyword">this</span>.CGLIB$CALLBACK_1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_1 = (NoOp)var1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// JVM加载这个类时会进行初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的代理对象继承了目标对象，并重写了目标对象的方法以此来达到增强目标对象的目的。实现net.sf.cglib.proxy.Factory的目的是提供一些创建代理对象实例的工厂方法，这些方法会比反射创建对象快。另外，要拦截在对象构造期间调用的方法，必须使用这些方法而不是反射。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        CGLIB是一个功能强大的高性能代码生成库。作为对JDK动态代理的补充，它为不实现接口的类提供代理解决方案。在底部，它使用ASM字节码操作框架。实际上，CGLIB通过生成子类来重写非final方法来代理。它比使用Java反射的JDK动态代理方法更快。CGLIB不能代理final类或final方法。一般来说，可以使用JDK动态代理方法来创建代理。对于没有接口或性能因素的情况，CGLIB是一个很好的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CGLIB介绍&quot;&gt;&lt;a href=&quot;#CGLIB介绍&quot; class=&quot;headerlink&quot; title=&quot;CGLIB介绍&quot;&gt;&lt;/a&gt;CGLIB介绍&lt;/h3&gt;&lt;p&gt;​        CGLIB是一个功能强大的高性能代码生成库。它被广泛应用于基于代理的AOP框架（如</summary>
      
    
    
    
    <category term="随笔" scheme="https://wonglay.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="CGLIB" scheme="https://wonglay.com/tags/CGLIB/"/>
    
    <category term="动态代理" scheme="https://wonglay.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="Java" scheme="https://wonglay.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CGLIB动态代理实现原理分析</title>
    <link href="https://wonglay.com/2020/12/01/cccc/"/>
    <id>https://wonglay.com/2020/12/01/cccc/</id>
    <published>2020-12-01T00:00:00.000Z</published>
    <updated>2023-05-03T07:56:45.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CGLIB介绍"><a href="#CGLIB介绍" class="headerlink" title="CGLIB介绍"></a>CGLIB介绍</h3><p>​        CGLIB是一个功能强大的高性能代码生成库。它被广泛应用于基于代理的AOP框架（如springaop和dynaop）中，以提供方法拦截。Hibernate作为最流行的ORM工具，也使用CGLIB库代理单端关联（除了collection lazy loading，它使用另一种机制）。EasyMock和jMock是流行的Java测试库。它们提供模拟对象来支持测试。两者都使用CGLIB代理没有接口的类。<br>​        CGLIB库使用ASM（一种轻量级但高性能的字节码操作框架）来转换字节码并生成新的类(如图1.1)。</p><p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20201218173519.jpg" alt="图1.1"></p><p>除了CGLIB之外，Groovy和Bean Shell等脚本语言也使用ASM来生成Java字节码。ASM使用类似于SAX analyzer的机制来实现高性能。但是，并不推荐直接使用ASM，因为这需要对JVM有很深的了解，包括类文件格式和指令集。<br>        另外，像Spring AOP和Hibernate这样的框架经常使用CGLIB和JDK动态代理来满足各自的需求。Hibernate使用JDK动态代理为webshere应用服务实现事务管理适配器；Spring AOP默认情况下使用JDK动态代理来代理接口，除非强制使用CGLIB，或者代理没有实现接口的类。</p><h3 id="CGLIB-API"><a href="#CGLIB-API" class="headerlink" title="CGLIB API"></a>CGLIB API</h3><p>​        CGLIB库虽然只有少量代码，但是由于缺乏文档，学习难度较大。CGLIB库的包结构如图2.1(本文采用Cglib 3.1)：</p><p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20201218143134.jpg" alt="图2.1"></p><ul><li>net.sf.cglib.beans：Java bean 相关的工具类</li><li>net.sf.cglib.core：底层字节码操作相关的类；大多数与ASP相关</li><li>net.sf.cglib.proxy：代理创建和方法拦截相关的类</li><li>net.sf.cglib.reflect：反射相关的类</li><li>net.sf.cglib.transform：编译和运行时类文件转换相关的类</li><li>net.sf.cglib.util：集合排序工具相关类</li></ul><p>对于创建动态代理，在大多数情况下，只需要使用代理包的部分API。<br>如上所述，CGLIB库基于ASM的上层应用程序。CGLIB对于代理不实现接口的类非常有用。本质上，对于需要代理的类，它只是动态地生成一个子类来覆盖非final方法，同时绑定钩子函数来回调自定义拦截器，这样就可以对目标类进行增强。值得一提的是，它比JDK动态代理更快。</p><p>net.sf.cglib.proxy.MethodInterceptor是最常用的回调类型，通常用于在基于代理的AOP实现中拦截方法回调。此接口只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * General-purpose &#123;<span class="doctag">@link</span> Enhancer&#125; callback which provides for &quot;around advice&quot;.//提供环绕通知的能力</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juozas Baliuka &lt;a href=&quot;mailto:baliuka@mwm.lt&quot;&gt;baliuka@mwm.lt&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> $Id: MethodInterceptor.java,v 1.8 2004/06/24 21:15:20 herbyderby Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * All generated proxied methods call this method instead of the original method.</span></span><br><span class="line"><span class="comment">     * The original method may either be invoked by normal reflection using the Method object,</span></span><br><span class="line"><span class="comment">     * or by using the MethodProxy (faster).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj &quot;this&quot;, the enhanced object // 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method intercepted Method // 目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args argument array; primitive types are wrapped // 目标方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy used to invoke super (non-intercepted method); may be called</span></span><br><span class="line"><span class="comment">     * as many times as needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable any exception may be thrown; if so, super method will not be invoked</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> any value compatible with the signature of the proxied method. Method returning void will ignore this value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> MethodProxy</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果net.sf.cglib.proxy.MethodInterceptor被设置为方法回调，当调用代理方法时，它调会用MethodInterceptor.intercept方法，然后再调用代理对象的方法,也就是目标方法。MethodInterceptor的intercept方法的第一个参数是代理对象，第二个参数和第三个参数分别是被拦截的方法和方法的参数，最后一个参数是代理方法。如果要调用代理对象的原始方法，可以使用java.lang.reflect方法对象来反射调用，或net.sf.cglib.proxy.MethodProxy对象。我们通常用net.sf.cglib.proxy.MethodProxy.MethodProxy，因为它更快。在intercept方法中，可以在目标方法调用之前或之后注入自定义代码(环绕通知)。</p><p>net.sf.cglib.proxy.MethodInterceptor满足大部分场景代理要求，但对于某些特定场景可能不太方便。为了易于使用和高性能，CGLIB提供了其他特殊的回调类型。例如，</p><ul><li>net.sf.cglib.proxy.FixedValue：在特定情况下，强制特定方法返回固定值，是非常有用和高性能的。</li></ul><ul><li>net.sf.cglib.proxy.NoOp：它直接传递父类的方法实现。</li></ul><ul><li>net.sf.cglib.proxy.LazyLoader：这在需要延迟加载代理对象的情况下非常有用。如果加载了代理对象，它将在以后的代理调用中重用。</li></ul><ul><li>net.sf.cglib.Dispatcher：类似于net.sf.cglib.proxy.LazyLoader，但每次调用代理方法时，都会调用loadObject方法来加载代理对象。</li></ul><ul><li>net.sf.cglib.proxy.ProxyRefDispatcher：与Dispatcher相同，但其loadObject方法支持传入的代理对象。</li></ul><p>我们通常对代理类的所有方法使用相同的回调，但是我们也可以使用net.sf.cglib.proxy.callsFilter对不同的方法使用不同的回调。然而JDK动态代理并没有提供这样的细粒度的控制。也就是说JDK中， java.lang.reflect.InvocationHandler的invoke方法不能对不同方法使用不同回调，只能使用相同的回调。</p><p>现在让我们看看如何使用CGLIB创建代理。</p><h3 id="用CGLIB-创建代理"><a href="#用CGLIB-创建代理" class="headerlink" title="用CGLIB 创建代理"></a>用CGLIB 创建代理</h3><p>​        使用Cglib可以很方便的创建代理。</p><h4 id="创建一个简单的代理"><a href="#创建一个简单的代理" class="headerlink" title="创建一个简单的代理"></a>创建一个简单的代理</h4><p>​        只需要传入一个目标类即可，Cglib就可以为该类创建代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetClass 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">     Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">     enhancer.setSuperclass(targetClass);</span><br><span class="line">     enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line">     <span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的返回值是目标类对象的代理。在上面的例子中，net.sf.cglib.proxy.Enhancer 配置了一个net.sf.cglib.proxy.Callback。如你所见，使用CGLIB创建一个简单的代理很容易。除了new一个net.sf.cglib.proxy.Enhancer对象，也可以net.sf.cglib.proxy.Enhancer中的静态辅助方法直接创建。但是建议使用示例中的方法，因为可以配net.sf.cglib.proxy.Enhancer对象来更精确地控制生成的代理。</p><p>值得注意的是，我们将目标类作为代理的父类传入。与JDK动态代理不同，我们不能使用目标对象来创建代理。目标对象只能由CGLIB创建。在本例中，默认的参数化构造函数用于创建目标对象。如果希望CGLIB用参数创建一个实例，那么应该使用net.sf.cglib.proxy.Enhancer.create(Class[]，Object[]）。方法的第一个参数指定参数类型，第二个参数指定参数值。参数中的基本类型需要包装类型。</p><h4 id="创建一个复杂的代理"><a href="#创建一个复杂的代理" class="headerlink" title="创建一个复杂的代理"></a>创建一个复杂的代理</h4><p>​        说复杂其实也不复杂，只是相对与上面简单类型而言，多了一些回调接口来实现不同类型的通知对目标类增强，例如前置通知等。</p><h5 id="使用MethodInterceptor"><a href="#使用MethodInterceptor" class="headerlink" title="使用MethodInterceptor"></a>使用MethodInterceptor</h5><p>​        我们可以替换net.sf.cglib.proxy.NoOp，实现net.sf.cglib.proxy.MethodInterceptor接口以获得更强的代理。代理对象的所有方法调用都分配给的intercept方法net.sf.cglib.proxy.MethodInterceptor. intercept方法然后调用底层对象。</p><p>​        假设您要检查是否有权限调用目标对象的某个方法，如果授权失败，可以抛出一个运行时异常AuthorizationException(本例中只是简单打印信息)。接口授权.java具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 简单的授权服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthorizationService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">authorize</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> net.sf.cglib.proxy.MethodInterceptor接口的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 一个简单的MethodInterceptor实现，应用AuthorizationService授权服务</span></span><br><span class="line"><span class="comment"> * 在调用代理方法前检查权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthorizationService authorizationService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizationInterceptor</span><span class="params">(AuthorizationService authorizationService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorizationService = authorizationService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (authorizationService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果授权失败，可以抛出AuthorizationException</span></span><br><span class="line">            authorizationService.authorize(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在intercept方法中，首先检查授权，如果授权通过，intercept方法调用目标对象的方法。出于性能原因，我们使用CGLIB net.sf.cglib.proxy.MethodProxy对象而不是常规java.lang.reflect方法反射对象来调用原始方法。</p><h5 id="使用CallbackFilter"><a href="#使用CallbackFilter" class="headerlink" title="使用CallbackFilter"></a>使用CallbackFilter</h5><p>​        net.sf.cglib.proxy.callsFilter允许在方法级别设置回调。假设有一个PersistenceServiceImpl类，它有两个方法：save和load。save方法需要授权检查，而load方法不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> PersistenceService接口简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersistenceService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Long id, String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(data + <span class="string">&quot; has been saved successfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;wonglay.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PersistenceService接口的net.sf.cglib.proxy.CallbackFilter实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceCallbackFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save方法在callback数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SAVE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save方法在callback数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOAD = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定哪个callback被调用当这个方法被调用的时候，callback</span></span><br><span class="line"><span class="comment">     * 就是一个MethodInterceptor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 正在被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 这个方法在callback数组中的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;save&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SAVE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LOAD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>accept方法将代理方法映射到MethodInterceptor，也即callback。这个方法返回callback对象数组的下标。下面是为PersistenceServiceImpl类创建代理对象的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.NoOp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wonglay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置需要代理的类</span></span><br><span class="line">        enhancer.setSuperclass(PersistenceServiceImpl.class);</span><br><span class="line"><span class="comment">// 设置PersistenceServiceImpl需要增强(检查权限)的方法过滤器</span></span><br><span class="line">        CallbackFilter callbackFilter = <span class="keyword">new</span> PersistenceServiceCallbackFilter();</span><br><span class="line">        enhancer.setCallbackFilter(callbackFilter);</span><br><span class="line"><span class="comment">// AuthorizationService 的简单实现</span></span><br><span class="line">        AuthorizationService authorizationService = (method) -&gt; &#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + methodName + <span class="string">&quot;] method authenticating...&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">       </span><br><span class="line">        Callback saveCallback = <span class="keyword">new</span> AuthorizationInterceptor(authorizationService);</span><br><span class="line">        Callback loadCallback = NoOp.INSTANCE;</span><br><span class="line">    <span class="comment">// 设置Callback</span></span><br><span class="line">        Callback[] callbacks = <span class="keyword">new</span> Callback[]&#123;saveCallback, loadCallback&#125;;</span><br><span class="line">        enhancer.setCallbacks(callbacks);</span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line">        PersistenceServiceImpl persistenceService = (PersistenceServiceImpl) enhancer.create();</span><br><span class="line">        System.out.println(persistenceService.load(<span class="number">1L</span>));</span><br><span class="line">        persistenceService.save(<span class="number">2L</span>, <span class="string">&quot;wonglay.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如图3.2.2，load方法调用没有打印权限检查信息，而save方法打印了权限检查信息，原因是load方法使用了NoOp.INSTANCE callback，它只是一个线程安全的空实现，而save方法使用了AuthorizationInterceptor callback对目标类进行增加，这里的通知(Advice)类型为前置通知。</p><p><img src="https://blog-wonglay.oss-cn-beijing.aliyuncs.com/article/img/20201218171429.jpg" alt="图3.2.2"></p><p>在本例中，授权拦截器应用于save方法，NoOp.INSTANCE 应用于load方法。你可以通net.sf.cglib.proxy.Enhancer.setInterfaces(Class [])指定代理需要实现的接口，但这不是必需的。<br>        对于net.sf.cglib.proxy.Enhancer，除了设置callback对象的数组外，还可以使用net.sf.cglib.proxy.Enhancer.setCallbackTypes(Class [])设置callback对象的数组。如果在代理创建期间没有实际的callback对象，则此方法非常有用。与callback对象一样，还需要使用net.sf.cglib.proxy.callsFilter为每个拦截方法指定callback对象数组的下标。</p><h3 id="底层实现原理探究"><a href="#底层实现原理探究" class="headerlink" title="底层实现原理探究"></a>底层实现原理探究</h3><p>​        当调用Enhancer的create方法创建代理对象时底层回调用下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Class gen = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">synchronized</span> (source) &#123;</span><br><span class="line">               ClassLoader loader = getClassLoader();</span><br><span class="line">               Map cache2 = <span class="keyword">null</span>;</span><br><span class="line">               cache2 = (Map)source.cache.get(loader);</span><br><span class="line">               <span class="keyword">if</span> (cache2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   cache2 = <span class="keyword">new</span> HashMap();</span><br><span class="line">                   cache2.put(NAME_KEY, <span class="keyword">new</span> HashSet());</span><br><span class="line">                   source.cache.put(loader, cache2);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (useCache) &#123;</span><br><span class="line">                   Reference ref = (Reference)cache2.get(key);</span><br><span class="line">                   gen = (Class) (( ref == <span class="keyword">null</span> ) ? <span class="keyword">null</span> : ref.get()); </span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (gen == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 先从当前线程获取</span></span><br><span class="line">                   Object save = CURRENT.get();</span><br><span class="line">                   CURRENT.set(<span class="keyword">this</span>);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">this</span>.key = key;</span><br><span class="line">                       <span class="keyword">if</span> (attemptLoad) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               gen = loader.loadClass(getClassName());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                               <span class="comment">// ignore</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (gen == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">byte</span>[] b = strategy.generate(<span class="keyword">this</span>);</span><br><span class="line">                           String className = ClassNameReader.getClassName(<span class="keyword">new</span> ClassReader(b));</span><br><span class="line">                           getClassNameCache(loader).add(className);</span><br><span class="line">                           <span class="comment">// 生成Class对象</span></span><br><span class="line">                           gen = ReflectUtils.defineClass(className, b, loader);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (useCache) &#123;</span><br><span class="line">                           cache2.put(key, <span class="keyword">new</span> WeakReference(gen));</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 利用反射创建对象</span></span><br><span class="line">                       <span class="keyword">return</span> firstInstance(gen);</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       CURRENT.set(save);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> firstInstance(gen);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们可以通过给JVM加一个Debug属性，使生成的代理对象输出到磁盘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将CGLIB用字节码框架ASM生成的Class文件输出的到磁盘</span></span><br><span class="line">      System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;D:\\java&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">      enhancer.setSuperclass(PersistenceServiceImpl.class);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的Class文件用IDE反编译得到如下代理类，此对象继承了目标对象，并且实现了Factory接口，该接口可用于创建此代理类型相同的实例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wonglay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.Signature;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Factory;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.NoOp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceImpl</span>$$<span class="title">EnhancerByCGLIB</span>$$<span class="title">f5def17a</span> <span class="keyword">extends</span> <span class="title">PersistenceServiceImpl</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// callbacks函数是否要和当前线程绑定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="comment">// 用于存放需要和当前线程绑定的callbacks</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    <span class="comment">// 本例中对应AuthorizationInterceptor</span></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="comment">// 本例中对应NoOp.INSTANCE</span></span><br><span class="line">    <span class="keyword">private</span> NoOp CGLIB$CALLBACK_1;</span><br><span class="line">    <span class="comment">// save的Method对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$save$<span class="number">1</span>$Method;</span><br><span class="line">    <span class="comment">// 为save方法创建的代理对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$save$<span class="number">1</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] CGLIB$emptyArgs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  CGLIB$save$1$Method 和 CGLIB$save$1$Proxy 对象就是MethodInterceptor接口的入参</span></span><br><span class="line"><span class="comment">    *  用MethodProxy 比用 Method反射调用方法更快</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        Class var0 = Class.forName(<span class="string">&quot;com.wonglay.PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a&quot;</span>);</span><br><span class="line">        Class var1;</span><br><span class="line">        <span class="comment">// 通过方法名称和方法描述符获取到save的Method对象</span></span><br><span class="line">        CGLIB$save$<span class="number">1</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;save&quot;</span>, <span class="string">&quot;(Ljava/lang/Long;Ljava/lang/String;)V&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;com.wonglay.PersistenceServiceImpl&quot;</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 为方法创建一个代理方法</span></span><br><span class="line">        CGLIB$save$<span class="number">1</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/Long;Ljava/lang/String;)V&quot;</span>, <span class="string">&quot;save&quot;</span>, <span class="string">&quot;CGLIB$save$1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$save$<span class="number">1</span>(Long var1, String var2) &#123;</span><br><span class="line">        <span class="keyword">super</span>.save(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  此方法重载了PersistenceServiceImpl的save方法，由于load方法的callback函数为NoOp.INSTANCE</span></span><br><span class="line"><span class="comment">    *  ，是一个空实现，所以未重载load方法，所以会直接调用PersistenceServiceImpl的load方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Long var1, String var2)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时调用MethodInterceptor的interceptor方法，在此interceptor方法进行通知</span></span><br><span class="line">            <span class="comment">// CGLIB$save$1$Method，CGLIB$save$1$Proxy参数在静态块中已经初始化了</span></span><br><span class="line">            var10000.intercept(<span class="keyword">this</span>, CGLIB$save$<span class="number">1</span>$Method, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;, CGLIB$save$<span class="number">1</span>$Proxy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.save(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodProxy CGLIB$findMethodProxy(Signature var0) &#123;</span><br><span class="line">        String var10000 = var0.toString();</span><br><span class="line">        <span class="keyword">switch</span>(var10000.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">279689439</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;save(Ljava/lang/Long;Ljava/lang/String;)V&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$save$<span class="number">1</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = var0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将callbacks绑定到当前线下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a var1 = (PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a)var0;</span><br><span class="line">        <span class="keyword">if</span> (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = <span class="keyword">true</span>;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">                <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Callback[] var10001 = (Callback[])var10000;</span><br><span class="line">            var1.CGLIB$CALLBACK_1 = (NoOp)((Callback[])var10000)[<span class="number">1</span>];</span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)var10001[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法，用于创建此类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var1);</span><br><span class="line">        PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a var10000 = <span class="keyword">new</span> PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;More than one callback object required&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法，用于创建此类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Class[] var1, Object[] var2, Callback[] var3)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var3);</span><br><span class="line">        PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a var10000 = <span class="keyword">new</span> PersistenceServiceImpl$$EnhancerByCGLIB$$f5def17a;</span><br><span class="line">        <span class="keyword">switch</span>(var1.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000.&lt;init&gt;();</span><br><span class="line">            CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> var10000;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Constructor not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        Object var10000;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            var10000 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Callback)var10000;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">int</span> var1, Callback var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">this</span>.CGLIB$CALLBACK_1 = (NoOp)var2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="keyword">public</span> Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callback[]&#123;<span class="keyword">this</span>.CGLIB$CALLBACK_0, <span class="keyword">this</span>.CGLIB$CALLBACK_1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现了Factory接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_1 = (NoOp)var1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// JVM加载这个类时会进行初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的代理对象继承了目标对象，并重写了目标对象的方法以此来达到增强目标对象的目的。实现net.sf.cglib.proxy.Factory的目的是提供一些创建代理对象实例的工厂方法，这些方法会比反射创建对象快。另外，要拦截在对象构造期间调用的方法，必须使用这些方法而不是反射。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        CGLIB是一个功能强大的高性能代码生成库。作为对JDK动态代理的补充，它为不实现接口的类提供代理解决方案。在底部，它使用ASM字节码操作框架。实际上，CGLIB通过生成子类来重写非final方法来代理。它比使用Java反射的JDK动态代理方法更快。CGLIB不能代理final类或final方法。一般来说，可以使用JDK动态代理方法来创建代理。对于没有接口或性能因素的情况，CGLIB是一个很好的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CGLIB介绍&quot;&gt;&lt;a href=&quot;#CGLIB介绍&quot; class=&quot;headerlink&quot; title=&quot;CGLIB介绍&quot;&gt;&lt;/a&gt;CGLIB介绍&lt;/h3&gt;&lt;p&gt;​        CGLIB是一个功能强大的高性能代码生成库。它被广泛应用于基于代理的AOP框架（如</summary>
      
    
    
    
    <category term="随笔" scheme="https://wonglay.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="CGLIB" scheme="https://wonglay.com/tags/CGLIB/"/>
    
    <category term="动态代理" scheme="https://wonglay.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="Java" scheme="https://wonglay.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP与AspectJ的比较</title>
    <link href="https://wonglay.com/2020/11/01/comparison-between-springaop-and-aspectj/"/>
    <id>https://wonglay.com/2020/11/01/comparison-between-springaop-and-aspectj/</id>
    <published>2020-11-01T00:00:00.000Z</published>
    <updated>2020-12-22T15:07:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如今已经存在很多AOP相关的类库，例如<a href="http://www.eclipse.org/aspectj/">AspectJ</a>、<a href="http://jac.aopsys.com/">JAC</a>、<a href="http://nanning.sf.net/">Nanning</a>等。这些类库都有它们独特的目标和规范。本文将比较Java中最流行的两个AOP框架，Spring AOP和AspectJ。</p><h3 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h3><p>在我们开始前先简单回顾一下AOP相关的术语和核心概念：</p><ul><li>Aspect(切面)：对一个横切多个类的关注点的一个模块化。事务管理是是一个横切关注点的一个很好的例子。在Spring AOP中，切面可以是通过基于XML(the schema-based approach)或用@Aspect注解(the @AspectJ style)来实现。</li><li>Join point(连接点)：是程序执行期间的一个点，例如方法的执行或异常的处理。在Spring AOP中，链接点总是表示一个方法的执行。</li><li>Advice(通知)：一个切面在连接点所采取的操作。有不同类型的通知，如前置通知、后置通知、环绕通知。许多AOP框架，包括Spring，将通知抽象成了一个拦截器，并在连接点周围维护了一个拦截器链。</li><li>Pointcut(切点)：一个匹配连接点的断言。通知与切点表达式相关联，并且与切点匹配的连接点上运行(例如，特定方法名的方法的执行)。与切点表达式匹配的连接点的概念是AOP的核心，Spring默认使用AspectJ切点表达式语言。</li><li>Introduction(引入)：代表一个类型额外的方法或字段。Spring AOP允许向任何增强的对象引入新的接口(以及相应的实现)。例如，你可以使用引入让一个bean实现IsModified接口来简化缓存。(在AspectJ社区中，引入称为类型间声明。)</li><li>Target object(目标对象)：一个被一个或多个切面增强(通知)的的对象。由于Spring AOP是通过运行时代理来实现的，所以这个对象始终是一个代理对象。</li><li>AOP proxy(AOP代理)：AOP框架为实现切面契约(通知方法的执行等)而创建的对象。在Spring框架中，AOP代理是JDK动态代理或CGLIB代理。</li><li>Weaving(织入)：将切面和其他应用程序类或对象链接以创建被增强的对象的过程。这可以是在编译期(例如使用AspectJ编译期)、加载期、运行期完成。Spring AOP 和其他纯Java AOP框架一样，在运行期植入。</li></ul><h3 id="Spring-AOP-与-AspectJ"><a href="#Spring-AOP-与-AspectJ" class="headerlink" title="Spring AOP 与 AspectJ"></a>Spring AOP 与 AspectJ</h3><p>现在我们从多个维度来讨论Spring AOP和AspectJ，例如能力、目标、织入方式、内部结构、连接点以及简易性。</p><h4 id="能力和目标"><a href="#能力和目标" class="headerlink" title="能力和目标"></a>能力和目标</h4><p>简单来说，Spring AOP 和AspectJ有不同的目标。</p><p>Spring AOP旨在通过Spring IoC容器来提供一个简单的AOP实现，以解决程序员面临的最常见问题。它并不是一个完整的AOP解决方案，它只能应用于由Spring容器管理的bean。</p><p>另一方面，AspectJ是最初的AOP技术，旨在提供完整的AOP解决方案。它比Spring AOP更健壮，但也要复杂得多。还值得注意的是，AspectJ可以应用于所有域对象。</p><h4 id="织入方式"><a href="#织入方式" class="headerlink" title="织入方式"></a>织入方式</h4><p>AspectJ和SpringAOP使用不同类型的织入方式，这会影响它们在性能和易用性方面的表现。</p><p>AspectJ使用三种不同的植入方式：</p><ul><li><strong>Compile-time weaving</strong>(编译时织入)：AspectJ编译期将切面和应用程序源代码作为输入，生成一个经过织入得类文件作为输出。</li><li><strong>Post-compile weaving</strong>(编译后织入)：也称为二进制织入。它是把切面织入现有的类文件或者JAR文件。</li><li><strong>Load-time weaving</strong>(加载时织入)：这与之前的二进制织入完全相同，区别在于织入过程延迟到类加载器加载类文件到JVM的时候。</li></ul><p>AspectJ使用编译时织入和类加载时织入，而Spring AOP使用运行时织入。</p><p>通过运行时织入，在应用程序执行过程中使用目标对象的代理（使用JDK动态代理或CGLIB代理）织入这些切面：</p><h4 id="内部结构及其应用"><a href="#内部结构及其应用" class="headerlink" title="内部结构及其应用"></a>内部结构及其应用</h4><p>Spring AOP 是一个基于代理的AOP框架。这意味着要将目标对象织入切面，它将创建该对象的代理。这可以通过以下两种方式实现：</p><ol><li>JDK动态代理 – Spring AOP 的首选方式。只要目标对象实现一个接口，就将使用JDK动态代理。</li><li>CGLIB 代理 – 如果对象没有实现接口，就会使用CGLIB代理。</li></ol><p>AspectJ在运行时不做任何事情，因为类是直接用aspect编译的。因此，与Spring AOP不同，它不需要任何设计模式。为了将切面织入到代码中，它引入了一个AspectJ编译器（ajc），通过它编译程序，然后通过提供一个小的（&lt;100K）运行库来运行程序。</p><h4 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h4><p>上面我们提到Spring AOP是基于代理的模式。因此，它需要将目标对象子类化，并应用相应的横切关注点。但是这也有局限性。我们不能将切面应用到被声明为final的类，因为声明为final的类不能被重写，这会导致运行时异常。同样，静态方法和final方法也一样，不能被重写。由于这些限制，Spring AOP只支持方法执行作为连接点。然而，AspectJ在运行前将切面织入到代码中。与Spring AOP 不同，它不要求对目标对象子类化，因此支持其他连接点，下面是这两者的支持的连接点比较：</p><table><thead><tr><th align="center">连接点</th><th align="center">Spring AOP</th><th align="center">AspectJ</th></tr></thead><tbody><tr><td align="center">方法调用</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">方法执行</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">构造方法调用</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">构造方法执行</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">静态代码块</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">对象初始化</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">字段引用</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">字段赋值</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">处理器执行</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">通知执行</td><td align="center">不支持</td><td align="center">支持</td></tr></tbody></table><p>值得注意的是，在Spring AOP中，切面不能应用于在同一个类中的方法调用，也就是说一个类中的方法中调用了这个类中的其他方法会导致切面失效。如下this.bar()的切面会失效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePojo</span> <span class="keyword">implements</span> <span class="title">Pojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this next method invocation is a direct call on the &#x27;this&#x27; reference</span></span><br><span class="line">        <span class="keyword">this</span>.bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为this是目标对象而不是AOP代理对象，将不会执行切面的通知方法。但是你可以使用AspectJ或者像下面这样(Spring不推荐这样使用，因为这样会耦合Spring框架和你的业务代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePojo</span> <span class="keyword">implements</span> <span class="title">Pojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this works, but... gah!</span></span><br><span class="line">        ((Pojo) AopContext.currentProxy()).bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简易性"><a href="#简易性" class="headerlink" title="简易性"></a>简易性</h4><p>Spring AOP 显然更简单，因为它没有在我们构建过程中引入任何额外的编译器或者织入器。因为它使用的是运行时织入，因此和我们通常的构建过程无缝集成。尽管它看起来简单，但是它只适用由Spring容器管理的bean。</p><p>然而，要使用AspectJ,我们需要引入AspectJ编译器(ajc)并且重新打包左右类库(除非我们使用后置织入或者载入时织入)。这当然比使用Spring AOP复杂，因为它引入了AspectJ Java工具(包括编译器(ajc)，调试器(ajdb)，文档生成器(ajdc)，程序结构浏览器(ajbrowser))，我们需要将这些工具与IDE或构件工具集成。</p><h4 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h4><p>就性能而言，编译时织入比运行时织入更快。Spring AOP 是一个基于代理的框架，因此需要在程序启动时创建代理对象。另外，每个切面还需要执行其它额外方法，这会对性能产生负面影响。</p><p>然而不像Spring AOP，AspectJ在应用程序执行前将切面织入到代码中，因此运行时没有额外的开销。</p><p>基于这些原因，基准测试表明AspectJ要比Spring AOP 快8到35倍。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个表格总结了Spring AOP 和AspectJ的关键不同之处：</p><table><thead><tr><th align="center">Spring AOP</th><th align="center">AspectJ</th></tr></thead><tbody><tr><td align="center">纯Java实现</td><td align="center">Java语言的扩展</td></tr><tr><td align="center">不需要额外编译器</td><td align="center">需要AspectJ编译器(除非采用LTW)</td></tr><tr><td align="center">仅支持运行时织入</td><td align="center">不支持运行时织入，支持编译时、载入时织入</td></tr><tr><td align="center">仅支持方法织入</td><td align="center">更强大，支持字段、方法构造器、静态块、final类/方法等</td></tr><tr><td align="center">仅支持由Spring容器管理的bean</td><td align="center">支持所有域对象</td></tr><tr><td align="center">仅支持方法执行切点</td><td align="center">支持所有切点</td></tr><tr><td align="center">为目标对象创建代理对象，将切面应用到代理对象</td><td align="center">程序执行前将切面植入到代码中</td></tr><tr><td align="center">性能更差</td><td align="center">性能更好</td></tr><tr><td align="center">容易学习和适用</td><td align="center">相对更复杂</td></tr></tbody></table><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>从前面分析可以看出，并不是一个框架优于另外一个，很大程度上取决我们的需求：</p><ul><li><p>框架：如果我们的应用没有使用Spring框架，那么我们只能放弃使用Spring AOP，因为Spring AOP依赖Spring容器。如果我们的应用使用了Spring框架，那么我们可以使用Spring AOP，因为她很容易学习和应用。</p></li><li><p>灵活性：由于连接点的限制，Spring AOP并不是一个完整的AOP解决方案，但它解决了程序员面临的常见问题。如果我们想用出了方法执行连接点以外的其他连接点的支持，那么使用AspectJ。</p></li><li><p>性能：如果我们使用少量的切面，那么性能差异很小。但是应用程序有成千上万的切面，那最好选择AspectJ。因为Aspect比Spring AOP快8到35倍。</p></li><li><p>同时使用：这两个框架完全兼容的。我们可以使用Spring AOP ，并仍然可以使用AspectJ来补充Spring AOP不支持的连接点。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如今已经存在很多AOP相关的类库，例如&lt;a href=&quot;http://www.eclipse.org/aspectj/&quot;&gt;AspectJ&lt;/a&gt;、&lt;a href=&quot;http://jac.aopsys.com/&quot;&gt;JAC&lt;/a&gt;、&lt;a href=&quot;http://nanning</summary>
      
    
    
    
    <category term="Frameworks" scheme="https://wonglay.com/categories/Frameworks/"/>
    
    <category term="Spring" scheme="https://wonglay.com/categories/Frameworks/Spring/"/>
    
    
    <category term="Spring" scheme="https://wonglay.com/tags/Spring/"/>
    
    <category term="AOP" scheme="https://wonglay.com/tags/AOP/"/>
    
    <category term="AspectJ" scheme="https://wonglay.com/tags/AspectJ/"/>
    
  </entry>
  
</feed>
