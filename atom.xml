<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WongLay&#39;s Blog</title>
  
  
  <link href="https://wonglay.com/atom.xml" rel="self"/>
  
  <link href="https://wonglay.com/"/>
  <updated>2020-11-08T14:29:38.403Z</updated>
  <id>https://wonglay.com/</id>
  
  <author>
    <name>wonglay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring AOP与AspectJ的比较</title>
    <link href="https://wonglay.com/2020/11/01/AOP%E5%92%8CAspectJ%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://wonglay.com/2020/11/01/AOP%E5%92%8CAspectJ%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-01T00:00:00.000Z</published>
    <updated>2020-11-08T14:29:38.403Z</updated>
    
    <content type="html"><![CDATA[<p>如今已经存在很多AOP相关的类库，例如<a href="http://www.eclipse.org/aspectj/">AspectJ</a>、<a href="http://jac.aopsys.com/">JAC</a>、<a href="http://nanning.sf.net/">Nanning</a>等。这些类库都有它们独特的目标和规范。本文将比较Java中最流行的两个AOP框架，Spring AOP和AspectJ。</p><h3 id="1-AOP的概念"><a href="#1-AOP的概念" class="headerlink" title="1. AOP的概念"></a>1. AOP的概念</h3><p>在我们开始前先简单回顾一下AOP相关的术语和核心概念：</p><ul><li>Aspect(切面)：对一个横切多个类的关注点的一个模块化。事务管理是是一个横切关注点的一个很好的例子。在Spring AOP中，切面可以是通过基于XML(the schema-based approach)或用@Aspect注解(the @AspectJ style)来实现。</li><li>Join point(连接点)：是程序执行期间的一个点，例如方法的执行或异常的处理。在Spring AOP中，链接点总是表示一个方法的执行。</li><li>Advice(通知)：一个切面在连接点所采取的操作。有不同类型的通知，如前置通知、后置通知、环绕通知。许多AOP框架，包括Spring，将通知抽象成了一个拦截器，并在连接点周围维护了一个拦截器链。</li><li>Pointcut(切点)：一个匹配连接点的断言。通知与切点表达式相关联，并且与切点匹配的连接点上运行(例如，特定方法名的方法的执行)。与切点表达式匹配的连接点的概念是AOP的核心，Spring默认使用AspectJ切点表达式语言。</li><li>Introduction(引入)：代表一个类型额外的方法或字段。Spring AOP允许向任何增强的对象引入新的接口(以及相应的实现)。例如，你可以使用引入让一个bean实现IsModified接口来简化缓存。(在AspectJ社区中，引入称为类型间声明。)</li><li>Target object(目标对象)：一个被一个或多个切面增强(通知)的的对象。由于Spring AOP是通过运行时代理来实现的，所以这个对象始终是一个代理对象。</li><li>AOP proxy(AOP代理)：AOP框架为实现切面契约(通知方法的执行等)而创建的对象。在Spring框架中，AOP代理是JDK动态代理或CGLIB代理。</li><li>Weaving(织入)：将切面和其他应用程序类或对象链接以创建被增强的对象的过程。这可以是在编译期(例如使用AspectJ编译期)、加载期、运行期完成。Spring AOP 和其他纯Java AOP框架一样，在运行期植入。</li></ul><h3 id="2-Spring-AOP-与-AspectJ"><a href="#2-Spring-AOP-与-AspectJ" class="headerlink" title="2. Spring AOP 与 AspectJ"></a>2. Spring AOP 与 AspectJ</h3><p>现在我们从多个维度来讨论Spring AOP和AspectJ，例如能力、目标、织入方式、内部结构、连接点以及简易性。</p><h4 id="2-1-能力和目标"><a href="#2-1-能力和目标" class="headerlink" title="2.1 能力和目标"></a>2.1 能力和目标</h4><p>简单来说，Spring AOP 和AspectJ有不同的目标。</p><p>Spring AOP旨在通过Spring IoC容器来提供一个简单的AOP实现，以解决程序员面临的最常见问题。它并不是一个完整的AOP解决方案，它只能应用于由Spring容器管理的bean。</p><p>另一方面，AspectJ是最初的AOP技术，旨在提供完整的AOP解决方案。它比Spring AOP更健壮，但也要复杂得多。还值得注意的是，AspectJ可以应用于所有域对象。</p><h4 id="2-2-织入方式"><a href="#2-2-织入方式" class="headerlink" title="2.2 织入方式"></a>2.2 织入方式</h4><p>AspectJ和SpringAOP使用不同类型的织入方式，这会影响它们在性能和易用性方面的表现。</p><p>AspectJ使用三种不同的植入方式：</p><ul><li><strong>Compile-time weaving</strong>(编译时织入)：AspectJ编译期将切面和应用程序源代码作为输入，生成一个经过织入得类文件作为输出。</li><li><strong>Post-compile weaving</strong>(编译后织入)：也称为二进制织入。它是把切面织入现有的类文件或者JAR文件。</li><li><strong>Load-time weaving</strong>(加载时织入)：这与之前的二进制织入完全相同，区别在于织入过程延迟到类加载器加载类文件到JVM的时候。</li></ul><p>AspectJ使用编译时织入和类加载时织入，而Spring AOP使用运行时织入。</p><p>通过运行时织入，在应用程序执行过程中使用目标对象的代理（使用JDK动态代理或CGLIB代理）织入这些切面：</p><h4 id="2-3-内部结构及其应用"><a href="#2-3-内部结构及其应用" class="headerlink" title="2.3 内部结构及其应用"></a>2.3 内部结构及其应用</h4><p>Spring AOP 是一个基于代理的AOP框架。这意味着要将目标对象织入切面，它将创建该对象的代理。这可以通过以下两种方式实现：</p><ol><li>JDK动态代理 – Spring AOP 的首选方式。只要目标对象实现一个接口，就将使用JDK动态代理。</li><li>CGLIB 代理 – 如果对象没有实现接口，就会使用CGLIB代理。</li></ol><p>AspectJ在运行时不做任何事情，因为类是直接用aspect编译的。因此，与Spring AOP不同，它不需要任何设计模式。为了将切面织入到代码中，它引入了一个AspectJ编译器（ajc），通过它编译程序，然后通过提供一个小的（&lt;100K）运行库来运行程序。</p><h4 id="2-3-连接点"><a href="#2-3-连接点" class="headerlink" title="2.3 连接点"></a>2.3 连接点</h4><p>上面我们提到Spring AOP是基于代理的模式。因此，它需要将目标对象子类化，并应用相应的横切关注点。但是这也有局限性。我们不能将切面应用到被声明为final的类，因为声明为final的类不能被重写，这会导致运行时异常。同样，静态方法和final方法也一样，不能被重写。由于这些限制，Spring AOP只支持方法执行作为连接点。然而，AspectJ在运行前将切面织入到代码中。与Spring AOP 不同，它不要求对目标对象子类化，因此支持其他连接点，下面是这两者的支持的连接点比较：</p><table><thead><tr><th align="center">连接点</th><th align="center">Spring AOP</th><th align="center">AspectJ</th></tr></thead><tbody><tr><td align="center">方法调用</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">方法执行</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">构造方法调用</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">构造方法执行</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">静态代码块</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">对象初始化</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">字段引用</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">字段赋值</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">处理器执行</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">通知执行</td><td align="center">不支持</td><td align="center">支持</td></tr></tbody></table><p>值得注意的是，在Spring AOP中，切面不能应用于在同一个类中的方法调用，也就是说一个类中的方法中调用了这个类中的其他方法会导致切面失效。如下this.bar()的切面会失效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePojo</span> <span class="keyword">implements</span> <span class="title">Pojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this next method invocation is a direct call on the &#x27;this&#x27; reference</span></span><br><span class="line">        <span class="keyword">this</span>.bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为this是目标对象而不是AOP代理对象，将不会执行切面的通知方法。但是你可以使用AspectJ或者像下面这样(Spring不推荐这样使用，因为这样会耦合Spring框架和你的业务代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePojo</span> <span class="keyword">implements</span> <span class="title">Pojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this works, but... gah!</span></span><br><span class="line">        ((Pojo) AopContext.currentProxy()).bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-简易性"><a href="#2-4-简易性" class="headerlink" title="2.4 简易性"></a>2.4 简易性</h4><p>Spring AOP 显然更简单，因为它没有在我们构建过程中引入任何额外的编译器或者织入器。因为它使用的是运行时织入，因此和我们通常的构建过程无缝集成。尽管它看起来简单，但是它只适用由Spring容器管理的bean。</p><p>然而，要使用AspectJ,我们需要引入AspectJ编译器(ajc)并且重新打包左右类库(除非我们使用后置织入或者载入时织入)。这当然比使用Spring AOP复杂，因为它引入了AspectJ Java工具(包括编译器(ajc)，调试器(ajdb)，文档生成器(ajdc)，程序结构浏览器(ajbrowser))，我们需要将这些工具与IDE或构件工具集成。</p><h4 id="2-5-性能差异"><a href="#2-5-性能差异" class="headerlink" title="2.5 性能差异"></a>2.5 性能差异</h4><p>就性能而言，编译时织入比运行时织入更快。Spring AOP 是一个基于代理的框架，因此需要在程序启动时创建代理对象。另外，每个切面还需要执行其它额外方法，这会对性能产生负面影响。</p><p>然而不像Spring AOP，AspectJ在应用程序执行前将切面织入到代码中，因此运行时没有额外的开销。</p><p>基于这些原因，基准测试表明AspectJ要比Spring AOP 快8到35倍。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.  总结"></a>3.  总结</h3><p>这个表格总结了Spring AOP 和AspectJ的关键不同之处：</p><table><thead><tr><th align="center">Spring AOP</th><th align="center">AspectJ</th></tr></thead><tbody><tr><td align="center">纯Java实现</td><td align="center">Java语言的扩展</td></tr><tr><td align="center">不需要额外编译器</td><td align="center">需要AspectJ编译器(除非采用LTW)</td></tr><tr><td align="center">仅支持运行时织入</td><td align="center">不支持运行时织入，支持编译时、载入时织入</td></tr><tr><td align="center">仅支持方法织入</td><td align="center">更强大，支持字段、方法构造器、静态块、final类/方法等</td></tr><tr><td align="center">仅支持由Spring容器管理的bean</td><td align="center">支持所有域对象</td></tr><tr><td align="center">仅支持方法执行切点</td><td align="center">支持所有切点</td></tr><tr><td align="center">为目标对象创建代理对象，将切面应用到代理对象</td><td align="center">程序执行前将切面植入到代码中</td></tr><tr><td align="center">性能更差</td><td align="center">性能更好</td></tr><tr><td align="center">容易学习和适用</td><td align="center">相对更复杂</td></tr></tbody></table><h3 id="4-如何选择"><a href="#4-如何选择" class="headerlink" title="4.  如何选择"></a>4.  如何选择</h3><p>从前面分析可以看出，并不是一个框架优于另外一个，很大程度上取决我们的需求：</p><ul><li><p>框架：如果我们的应用没有使用Spring框架，那么我们只能放弃使用Spring AOP，因为Spring AOP依赖Spring容器。如果我们的应用使用了Spring框架，那么我们可以使用Spring AOP，因为她很容易学习和应用。</p></li><li><p>灵活性：由于连接点的限制，Spring AOP并不是一个完整的AOP解决方案，但它解决了程序员面临的常见问题。如果我们想用出了方法执行连接点以外的其他连接点的支持，那么使用AspectJ。</p></li><li><p>性能：如果我们使用少量的切面，那么性能差异很小。但是应用程序有成千上万的切面，那最好选择AspectJ。因为Aspect比Spring AOP快8到35倍。</p></li><li><p>同时使用：这两个框架完全兼容的。我们可以使用Spring AOP ，并仍然可以使用AspectJ来补充Spring AOP不支持的连接点。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如今已经存在很多AOP相关的类库，例如&lt;a href=&quot;http://www.eclipse.org/aspectj/&quot;&gt;AspectJ&lt;/a&gt;、&lt;a href=&quot;http://jac.aopsys.com/&quot;&gt;JAC&lt;/a&gt;、&lt;a href=&quot;http://nanning</summary>
      
    
    
    
    <category term="frameworks" scheme="https://wonglay.com/categories/frameworks/"/>
    
    <category term="Spring" scheme="https://wonglay.com/categories/frameworks/Spring/"/>
    
    
    <category term="Spring" scheme="https://wonglay.com/tags/Spring/"/>
    
    <category term="AOP" scheme="https://wonglay.com/tags/AOP/"/>
    
    <category term="AspectJ" scheme="https://wonglay.com/tags/AspectJ/"/>
    
  </entry>
  
</feed>
